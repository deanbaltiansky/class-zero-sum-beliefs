[{"name":"app.R","content":"# study-1/app/app.R\nlibrary(shiny)\n\n`%||%` <- function(x, y) if (is.null(x)) y else x\n\n# -----------------------------\n# User-configured variable list\n# -----------------------------\nnumeric_vars_user <- c(\n  # Class Zero-Sum: edit as needed; tolerant matching will bridge small diffs\n  \"zs_class\",\"SDO\",\"zsm\",\"lnktfate\",\"soli\",\"support\",\n  \"ideo_con\",\"ideo_lib\",\"ideo_demsoc\",\"ideo_lbrtn\",\"ideo_prog\",\n  \"man\",\"white\",\"age\",\"income_num\",\"edu_num\"\n)\n\n# -----------------------------\n# Data + var info loaders\n# -----------------------------\nload_data <- function() {\n  # Canonical filename for this project\n  p <- \"data/df_czs_elg.csv\"\n  if (!file.exists(p)) {\n    stop(\"Missing data/df_czs_elg.csv in app/data/ . Place the file at study-1/app/data/\")\n  }\n  read.csv(p, check.names = FALSE, stringsAsFactors = FALSE)\n}\n\nload_var_info <- function() {\n  p <- \"data/var_info.csv\"\n  if (!file.exists(p)) {\n    return(data.frame(var = character(), label = character(), description = character(),\n                      stringsAsFactors = FALSE))\n  }\n  vi <- read.csv(p, check.names = FALSE, stringsAsFactors = FALSE)\n  names(vi) <- tolower(names(vi))\n  if (!\"var\" %in% names(vi)) vi$var <- character(0)\n  if (!\"label\" %in% names(vi)) vi$label <- vi$var\n  if (!\"description\" %in% names(vi)) vi$description <- \"\"\n  vi$var <- trimws(vi$var)\n  vi$label <- ifelse(nzchar(trimws(vi$label)), trimws(vi$label), vi$var)\n  vi$description <- trimws(vi$description)\n  unique(vi[c(\"var\",\"label\",\"description\")])\n}\n\n# -----------------------------\n# UI\n# -----------------------------\nui <- tagList(\n  tags$head(\n    tags$title(\"Correlations App\"),\n    tags$script(HTML('window.addEventListener(\"load\", function(){ document.title = \"Correlations App\"; });'))\n  ),\n  fluidPage(\n    title = \"Correlations App\",\n    titlePanel(\"Class Zero-Sum Beliefs â€” Correlations\"),\n    sidebarLayout(\n      sidebarPanel(\n        helpText(\"Pick two continuous variables to explore their linear relationship.\"),\n        selectInput(\"xvar\", \"X axis\", choices = NULL),\n        selectInput(\"yvar\", \"Y axis\", choices = NULL),\n        tags$hr(),\n        tags$details(\n          tags$summary(\"Debug: detected columns\"),\n          verbatimTextOutput(\"debug_cols\", placeholder = TRUE)\n        )\n      ),\n      mainPanel(\n        plotOutput(\"scatter\", height = 420),\n        tags$hr(),\n        verbatimTextOutput(\"stats\"),\n        tags$hr(),\n        tags$h4(\"Variable descriptions\"),\n        uiOutput(\"xdesc\"),\n        uiOutput(\"ydesc\")\n      )\n    )\n  )\n)\n\n# -----------------------------\n# Server\n# -----------------------------\nserver <- function(input, output, session) {\n  df <- load_data()\n  var_info <- load_var_info()\n  \n  # --- tolerant name normalization (case/space/underscore) ---\n  norm_name <- function(x) tolower(gsub(\"\\\\s+\", \"_\", trimws(x)))\n  \n  # Map: normalized df name -> original df name (so we always use real columns)\n  df_colmap <- setNames(names(df), nm = norm_name(names(df)))\n  \n  # Normalize var_info too, for resilient label/description lookup\n  if (nrow(var_info)) {\n    var_info$var_norm <- norm_name(var_info$var)\n  }\n  \n  # Resolve requested names to actual df columns using normalized map\n  resolve_cols <- function(requested) {\n    req_norm <- norm_name(requested)\n    hits <- df_colmap[intersect(req_norm, names(df_colmap))]\n    unname(hits)\n  }\n  \n  # Helpers for labels/descriptions (try exact, then normalized)\n  get_label <- function(v) {\n    if (is.null(v) || !nzchar(v) || !nrow(var_info)) return(v %||% \"\")\n    hit <- var_info$label[var_info$var == v]\n    if (length(hit) == 1 && nzchar(hit)) return(hit)\n    if (\"var_norm\" %in% names(var_info)) {\n      hit2 <- var_info$label[var_info$var_norm == norm_name(v)]\n      if (length(hit2) == 1 && nzchar(hit2)) return(hit2)\n    }\n    v\n  }\n  \n  get_desc <- function(v) {\n    if (is.null(v) || !nzchar(v) || !nrow(var_info)) return(\"No description found.\")\n    hit <- var_info$description[var_info$var == v]\n    if (length(hit) == 1 && nzchar(hit)) return(hit)\n    if (\"var_norm\" %in% names(var_info)) {\n      hit2 <- var_info$description[var_info$var_norm == norm_name(v)]\n      if (length(hit2) == 1 && nzchar(hit2)) return(hit2)\n    }\n    \"No description found.\"\n  }\n  \n  # -----------------------------\n  # Build available choices\n  # -----------------------------\n  # 1) Try curated list first\n  resolved <- resolve_cols(numeric_vars_user)\n  \n  # 2) Fallback: auto-detect numeric-ish columns so the app is usable immediately\n  if (length(resolved) < 2) {\n    is_numish <- vapply(df, function(x) {\n      if (is.numeric(x)) return(TRUE)\n      if (is.character(x)) {\n        sup <- suppressWarnings(as.numeric(x))\n        return(any(!is.na(sup)))\n      }\n      FALSE\n    }, logical(1))\n    resolved <- names(df)[is_numish]\n  }\n  \n  # 3) Keep order stable and unique\n  available <- unique(intersect(resolved, names(df)))\n  \n  validate(\n    need(length(available) >= 2,\n         paste0(\n           \"Not enough variables to run.\\n\\n\",\n           \"CSV columns detected (first 30):\\n  - \",\n           paste(utils::head(names(df), 30), collapse = \"\\n  - \"), \"\\n\\n\",\n           \"Your requested list (first 30):\\n  - \",\n           paste(utils::head(numeric_vars_user, 30), collapse = \"\\n  - \"), \"\\n\\n\",\n           \"Tip: check for small name differences (case/underscores/spaces).\"\n         ))\n  )\n  \n  # Names shown = labels; values = actual df column names\n  choice_labels <- vapply(available, get_label, character(1))\n  # If any labels are \"\", fall back to the column name\n  choice_labels[!nzchar(choice_labels)] <- available[!nzchar(choice_labels)]\n  choices <- setNames(object = available, nm = choice_labels)\n  \n  updateSelectInput(session, \"xvar\", choices = choices, selected = available[1])\n  updateSelectInput(session, \"yvar\", choices = choices, selected = available[2])\n  \n  # -----------------------------\n  # Reactive data for selected pair\n  # -----------------------------\n  pair_data <- reactive({\n    req(input$xvar, input$yvar)\n    vars <- c(input$xvar, input$yvar)\n    vars <- intersect(vars, names(df))\n    validate(need(length(vars) == 2, \"Pick two valid variables.\"))\n    \n    d <- df[, vars, drop = FALSE]\n    d[] <- lapply(d, function(x) if (is.character(x)) suppressWarnings(as.numeric(x)) else x)\n    d <- stats::na.omit(d)\n    validate(\n      need(nrow(d) >= 3, \"Not enough non-missing pairs to plot.\"),\n      need(stats::sd(d[[1]]) > 0, \"X has no variance.\"),\n      need(stats::sd(d[[2]]) > 0, \"Y has no variance.\")\n    )\n    d\n  })\n  \n  # -----------------------------\n  # Outputs\n  # -----------------------------\n  output$scatter <- renderPlot({\n    d <- pair_data()\n    plot(\n      d[[1]], d[[2]], pch = 19,\n      xlab = get_label(input$xvar),\n      ylab = get_label(input$yvar)\n    )\n    fit <- lm(d[[2]] ~ d[[1]])\n    abline(fit, lwd = 2)\n  })\n  \n  output$stats <- renderText({\n    d <- pair_data()\n    ct <- cor.test(d[[1]], d[[2]], method = \"pearson\")\n    sprintf(\"Pearson r = %.3f   (p = %.3g,  n = %d)\",\n            unname(ct$estimate), ct$p.value, nrow(d))\n  })\n  \n  output$xdesc <- renderUI({\n    req(input$xvar)\n    tags$p(tags$strong(\"X: \"), tags$em(get_desc(input$xvar)))\n  })\n  \n  output$ydesc <- renderUI({\n    req(input$yvar)\n    tags$p(tags$strong(\"Y: \"), tags$em(get_desc(input$yvar)))\n  })\n  \n  output$debug_cols <- renderText({\n    paste0(\n      \"df columns (first 50):\\n  - \",\n      paste(utils::head(names(df), 50), collapse = \"\\n  - \"),\n      \"\\n\\nMatched available choices:\\n  - \",\n      paste(available, collapse = \"\\n  - \")\n    )\n  })\n}\n\nshinyApp(ui, server)\n","type":"text"}]
